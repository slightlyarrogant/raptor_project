Kalendarz/Gantt
Metadata

url: http://192.168.33.19/master/docs/developers/ui/schedulers
scraped_at: 2024-09-05T12:18:46.643001
last_updated: 2024-09-05T12:18:46.643043
parent_id: 21c021b76586e248072c806c95187f09
path: aPaczka Plugin/Dobre praktyki/Szkolenia - B2B/Zestawienie webinaria/Zestawienie eSzkolenia/Inter stal/Handel/Magazyn/Praca z czytnikiem/Rozliczenie produkcji/Ustawienia Przyjmowanie Towaru na pakowaniu/Laguna/Analizy/Okucia/Montan stal/Kalendarz/Gantt
meta_tags: ['item', 'view', 'interval', 'taska', 'public', 'summary', 'element', 'właściwości', 'param', 'object']

Content
Atrybut UIVendoScheduler
Do osadzenia kalendarza/gantta na view modelu służy atrybut UIVendoScheduler Należy go dodać do właściwości zwracającej obiekt klasy dziedziczącej po SchedulerDataSource - oznaczający źródło dla danych (provider).
Właściwości atrybutu UIVendoScheduler:
Właściwość atrybutu| Typ właściwości na view modelu| Znaczenie| VisibleIntervalProperty| DateTimeInterval| Widoczny interwał na osi czasu| SelectedTaskProperty| Taki jak typ "taska"| Wybrany "task" - np. poprzez kliknięcie| AutoRefreshPanelProperty| bool| Czy panel odświeżania jest dostępny| SettingsContextProperty| SettingsContext| Kontekst ustawień - zapis układu kalendarza| SettingsContextNameProperty| string| Klucz pod jakim zapisane są ustawienia kalendarza w przypadku, gdy nie zostanie podany, wówczas zastosowany jest domyślny o wartości "Scheduler"| OptionsProperty| VendoUISchedulerOptions| Obiekt zawierający parametry inicjalizacyjne dla definicji wyglądu kalendarza/gantta
---|---|---  
Uwaga : Każda z właściwości powinna być bindowana z obiektem odpowiedniego typu (do właściwości przypisujemy odpowiednią nazwę publicznej właściwości z view modelu).
Parametry inicjalizacyjne - właściwości VendoUISchedulerOptions
Nazwa| Typ| Znaczenie| Wartość domyślna| VerticalTimeLine| bool?| Czy oś czasu jest prezentowana wertykalnie| false| ElementHeaderSize| int?| Rozmiar nagłówka dla elementu| 20| TimeScale| TimeSpan?| Skala na osi czasu| 1 godzina| TimeMaximumScale| TimeSpan?| Maksymalna wartość dla skali na osi czasu| 14 dni| TimeScalePartSize| int?| Rozmiar (w pikselach) jednej jednostki skali na osi czasu| | TimeZooms| TimeSpan[]| Skale dla osi czasu| Minuty: 1, 2, 5, 15, 30; Godziny: 1, 2, 4, 6, 12; Dni: 1, 2, 4, 7, 14, 28, 28 * 4, 28 * 6; Lata: 1, 2, 4, 5, 10| FadeNotSelectedOrNotConnected| bool?| Czy po wybraniu taska pozostałe niewybrane mają się "wyszarzyć"| false| GantConnections| bool?| Czy wyświetlać połączenia między taskami| true| ShowInnerLines| bool?| Czy pokazywać linie wewnętrzne| true| MinimalSize| bool?| Czy tak ma minimalny rozmiar| false| ExactDates| bool?| Czy wyświetlać taski z dokładnością do dat| true| AutoRefreshPanel| bool?| Czy panel auto odświeżania jest dostępny| false| AutoRefresh| TimeSpan?| Co jaki czas ma nastąpić żądanie odświeżenia widoku| 1 minuta| AllowMoveTask| bool?| Czy pozwalać na przenoszenie "tasków"| true
---|---|---|---  
Dane - obiekt klasy SchedulerDataSource
Przykład:
public class MyDataSource : SchedulerDataSource
{
    public MyDataSource(): base(typeof(TaskModel), nameof(TaskModel.Interval), nameof(TaskModel.Element)) 
    { 
        // Opcjonalne
        TaskDescriptor.ColorAccessor = nameof(TaskModel.Color);
    }

    // Zwraca listę wierszy.
    public override IList<object> LoadElements() { ... }
    // Ładuje zawartość kalendarza/Gantta
    public override void LoadContent(SchedulerDataSourceView view) 
    { 
        var interval = view.Interval;

        // Zadania
        foreach (var item in Tasks)
            if (interval.IntersectsWith(item.Interval) && view.Elements.Contains((object)item.Element))
                view.AddTask(item);

        // Połączenia między zadaniami
        foreach (var item in Connections)
            if (interval.IntersectsWith(item.TaskA.Interval) && view.Elements.Contains((object)item.TaskA.Element)
                || interval.IntersectsWith(item.TaskB.Interval) && view.Elements.Contains((object)item.TaskB.Element))
                view.AddConnection(item.TaskA, item.TaskB, true, item.Color)

        // Tło
        for (int i = 0; i <= (interval.End - interval.Start).TotalDays + 1; i++)
            foreach (var item in view.Elements)
            {
                var start = interval.Start.Date.SafeAdd(i, 8, 0);
                var end = start.SafeAdd(0, 8, 0);

                view.AddWorkTime(item, new DateTimeInterval(start, end));
            }

        // Wykresy
        foreach (var item in Graphs)
            view.AddGraph(item.Item1, item.Item2);

        // Markery
        foreach (var marker in Markers)
            view.AddMarker(marker.Item1, marker.Item2, marker.Item3);
    }

    // Opcjonalne
    public override void Reset() { ... }

    // Przykładowa klasa jako kontener na dane dla taska
    public class TaskModel
    {
        public object Element { get ;set; }
        public DateTimeInterval Interval { get ;set; }
        public Color Color { get; set;} // Opcjonalne
    }
}

Deskryptory
Poprzez deskryptory określa się sposób dostępu do takich danych jak np. kolor tła czy obramowania taska. Powiązanie danych może nastąpić bezpośrednio poprzez podanie nazwy publicznej właściwości np.
TaskDescriptor.ColorAccessor = nameof(TaskModel.Color);

lub poprzez przekazanie delegata
TaskDescriptor.ColorDelegate = GetTaskColor;

Akcje

wywołanie odświeżenia danych i przerysowanie kontrolki typ DataSource (inaczej obiektu, z którym powiązany został atrybut VendoUIScheduler) musi implementować interfejs IViewModelWithSchedulerRefresh - akcja następuje po wywołaniu eventu Refresh.

podpięcie pod przenoszenie taska (o ile jest to ustawione) klasa określająca typ "taska" musi implementować interfejs IViewModelWithSchedulerMovingSupport
public interface IViewModelWithSchedulerMovingSupport
{
    /// 
    /// Czy można przesunąć zdarzenie na kalendarzu.
    /// 
    /// Nowy element.
    /// Nowy przedział.
    /// Czy można przesunąć zdarzenie na kalendarzu.
    bool SchedulerCanMove(object newElement, DateTimeInterval newInterval);
/// <summary>
/// Wykonuje przesunięcie zdarzenia.
/// </summary>
/// <param name="newElement">Nowy element.</param>
/// <param name="newInterval">Nowy przedział.</param>
/// <returns>Czy przeładować dane.</returns>
bool SchedulerMove(object newElement, DateTimeInterval newInterval);

}


podpięcie pod zdarzenie kliknięcia lub podwójnego kliknięcia klasa określająca typ "taska" musi implementować interfejs IViewModelWithClickSupport
/// 
/// ViewModel wspierający kliknięcia.
/// 
public interface IViewModelWithClickSupport
{
    /// 
    /// Wykonuje kliknięcie w element.
    /// 
    void Click();
/// <summary>
/// Wykonuje podwójne kliknięcie w element.
/// </summary>
void DoubleClick();

}

